<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.9.2" />
<title>sqlalchemy_pydantic_orm.main API documentation</title>
<meta name="description" content="This is the main and also the only module of the sqlalchemy-pydantic-orm
package. It consists of one class called ORMBaseSchema, which contains all â€¦" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>sqlalchemy_pydantic_orm.main</code></h1>
</header>
<section id="section-intro">
<p>This is the main and also the only module of the sqlalchemy-pydantic-orm
package. It consists of one class called ORMBaseSchema, which contains all the
functionality. In the future there will also be a methods that generates
schemas from SQLAlchemy models.</p>
<p>The ORMBaseSchema is an extension of the Pydantic's BaseModel. It can use the
fields defined in it's own schema to create a SQLAlchemy model, it can do that
by using a mandatory predefined link to a corresponding SQLAlchemy model.</p>
<h2 id="references">References</h2>
<p><a href="https://pydantic-docs.helpmanual.io/usage/models/">https://pydantic-docs.helpmanual.io/usage/models/</a>
<a href="https://fastapi.tiangolo.com/tutorial/sql-databases/">https://fastapi.tiangolo.com/tutorial/sql-databases/</a></p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;
This is the main and also the only module of the sqlalchemy-pydantic-orm
package. It consists of one class called ORMBaseSchema, which contains all the
functionality. In the future there will also be a methods that generates
schemas from SQLAlchemy models.


The ORMBaseSchema is an extension of the Pydantic&#39;s BaseModel. It can use the
fields defined in it&#39;s own schema to create a SQLAlchemy model, it can do that
by using a mandatory predefined link to a corresponding SQLAlchemy model.

References:
    https://pydantic-docs.helpmanual.io/usage/models/
    https://fastapi.tiangolo.com/tutorial/sql-databases/
&#34;&#34;&#34;

from abc import abstractmethod
from collections import deque
from typing import Any, Type

from pydantic import BaseModel
from sqlalchemy.orm import Session
from sqlalchemy.orm.decl_api import DeclarativeMeta

SUPPORTED_ITERABLES = (list, tuple, set, deque)  # Could be extended


class ORMBaseSchema(BaseModel):
    class Config:
        &#34;&#34;&#34;Pydantic&#39;s default config class except with orm_mode set to True.&#34;&#34;&#34;

        orm_mode = True

    def __init__(self, **data: Any):
        &#34;&#34;&#34;The init is used for validation and throwing errors where needed.

        Pydantic catches all ValueError&#39;s in initialization, and then outputs
        the error message in a easy to read format with the specific class
        name displayed.
        Every error is given the &#34;sqlalchemy-pydantic-orm&#34; identifier to
        distinguish between Pydantic&#39;s or SQLAlchemy&#39;s own errors
        and those of this package.

        For performance its better to execute the `super().__init__()` as late
        as possible, only the _orm_model check requires it to work properly.

        Args:
            **data (Any):
                The fields and values to be validated.

        Raises:
            ValueError:
                When orm_mode is set to false /
                When the provided _orm_model is invalid
        &#34;&#34;&#34;
        if not hasattr(config := self.Config, &#34;orm_mode&#34;):
            # Overwriting when not defined
            config.orm_mode = True
        elif not config.orm_mode:
            # Throws an error instead of overwriting to avoid confusion
            raise ValueError(
                &#34;sqlalchemy-pydantic-orm: &#34;
                &#34;When adding your own &#39;Config&#39; class, &#34;
                &#34;make sure you set &#39;orm_mode&#39; to &#39;true&#39;&#34;
            )

        super().__init__(**data)

        if type(self._orm_model) != DeclarativeMeta:
            raise ValueError(
                &#34;sqlalchemy-pydantic-orm: &#34;
                &#34;Provided orm_model is not a valid SQLAlchemy model, &#34;
                &#34;make sure it inherits the declarative base&#34;
            )
        elif &#34;_orm_model&#34; not in self.__private_attributes__:
            raise ValueError(
                &#34;sqlalchemy-pydantic-orm: &#34;
                &#34;Provided orm_model is not wrapped in a pydantic PrivateAttr&#34;
            )

    @property
    @abstractmethod
    def _orm_model(self) -&gt; Type[DeclarativeMeta]:
        &#34;&#34;&#34;The corresponding SQLAlchemy model class

        The property decorator is used together with the @abstractmethod
        decorator to enforce assignment.

        This variable/property has a leading underscore and can only be
        assigned as PrivateAttr (Pydantic). This is because a Pydantic schema
        iterates over it&#39;s own fields and would otherwise cause problems when
        encountering this variable/property.

        Returns:
            A SQLAlchemy model (indirectly) inherited from DeclarativeMeta
        &#34;&#34;&#34;
        pass

    def orm_create(self, **extra_fields: Any) -&gt; DeclarativeMeta:
        &#34;&#34;&#34;Method to convert a (nested) pydantic schema to a SQLAlchemy model.

        Using the validated fields in this class, together with the defined
        _orm_model, this recursive methods creates a (nested) SQLAlchemy model.

        Args:
            extra_fields (Any):
                Extra fields (keyword arguments) not defined in the pydantic
                schema used by the top level ORM model. The fields in the
                schema itself have priority.

                Usage example:
                    When using an API like FastAPI or Flask, you often get
                    the data as body while getting the id (foreign key) as
                    path parameter. This argument lets you add such an id from
                    a separate source.

        Returns:
            A SQLAlchemy model instance, that still has to be added to the db.

        Raises:
            TypeError:
                When a list is not fully consisted of other ORM schemas.
        &#34;&#34;&#34;
        current_level_fields = {}
        for field in self.__fields_set__:
            field_name = self.__fields__[field].alias
            value = getattr(self, field)
            if isinstance(value, ORMBaseSchema):  # One-to-one
                current_level_fields[field_name] = value.orm_create()

            elif isinstance(value, SUPPORTED_ITERABLES):  # One-to-many
                models = []
                for schema in value:
                    if not isinstance(schema, ORMBaseSchema):
                        raise TypeError(
                            &#34;Lists should only contain other schemas &#34;
                            f&#34;inherited from &#39;{ORMBaseSchema.__name__}&#39; &#34;
                            &#34;(sqlalchemy-pydantic-orm)&#34;
                        )
                    models.append(schema.orm_create())
                current_level_fields[field_name] = models

            else:  # value without relation
                current_level_fields[field_name] = value

        return self._orm_model(**extra_fields, **current_level_fields)

    def orm_update(self, db: Session, db_model: DeclarativeMeta) -&gt; None:
        &#34;&#34;&#34;Method to update a (nested) orm structure.

        This method recursively updates an orm model with it&#39;s relationships.

        In one-to-many relationships, each provided item without an id gets
        added as new item with the `orm_create()` method. When a valid id is
        provided it updates the item with the `orm_update()` method. It also
        keep track of the parsed database items, and afterwards deletes any
        unparsed item.

        Args:
            db (Session):
                Database session used for `.add()` and `.delete()`.
            db_model (DeclarativeMeta):
                The ORM model to be updated.

        Returns:
            Nothing, everything gets done in the provided db_model

        Raises:
            TypeError:
                When a list is not fully consisted of other ORM schemas.
            ValueError:
                When the provided db_model is not valid /
                When a given id is not found in the database
        &#34;&#34;&#34;
        if not isinstance(db_model, self._orm_model):
            raise ValueError(
                f&#34;Provided db_model &#39;{db_model}&#39; is not an instance of the &#34;
                f&#34;defined _orm_model &#39;{self._orm_model.__name__}&#39; &#34;
                &#34;(sqlalchemy-pydantic-orm)&#34;
            )
        for field in self.__fields_set__:
            field_name = self.__fields__[field].alias
            db_value = getattr(db_model, field_name)
            update_value = getattr(self, field)
            if isinstance(update_value, ORMBaseSchema):  # One-to-one
                if db_value:
                    update_value.orm_update(db, db_value)
                else:
                    setattr(db_model, field_name, update_value.orm_create())

            elif isinstance(update_value, SUPPORTED_ITERABLES):  # One-to-many
                parsed_items = set()
                for schema in update_value:
                    if not isinstance(schema, ORMBaseSchema):
                        raise TypeError(
                            &#34;Lists should only contain other schemas &#34;
                            f&#34;inherited from &#39;{ORMBaseSchema.__name__}&#39; &#34;
                            &#34;(sqlalchemy-pydantic-orm)&#34;
                        )
                    if item_id := getattr(schema, &#34;id&#34;, None):
                        try:
                            db_item = next(
                                item for item in db_value if item.id == item_id
                            )
                        except StopIteration:
                            raise ValueError(
                                f&#34;Provided id &#39;{item_id}&#39; &#34;
                                f&#34;for field &#39;{field_name}&#39; &#34;
                                &#34;can&#39;t be found in the database &#34;
                                &#34;(sqlalchemy-pydantic-orm)&#34;
                            ) from None  # removes unnecessary traceback

                        schema.orm_update(db, db_item)
                        parsed_items.add(db_item)
                    else:
                        new_item = schema.orm_create()
                        parsed_items.add(new_item)
                        db_value.append(new_item)

                for db_item in db_value:
                    if db_item not in parsed_items:
                        db.delete(db_item)
            else:
                setattr(db_model, field_name, update_value)

    def to_orm(self, db: Session, **extra_fields: Any) -&gt; DeclarativeMeta:
        &#34;&#34;&#34;Method that combines the functionality of orm_create &amp; orm_update.

        This method is a wrapper around the other two methods. When no id is
        provided, it creates a new model with orm_create, and when an id Ã­s
        provided, it retrieves and updates that model.

        In contrary to the orm_create function on its own, this function does
        add the newly created model to the database. So after the this method
        has been executed you only need to call `db.commit()` after.

        Args:
            db (Session):
            **extra_fields (Any):

        Returns:
            A SQLAlchemy model instance, which is either queried and updated,
                or newly created

        Raises:
            ValueError:
                When the provided id is not found in the database
        &#34;&#34;&#34;
        id_ = getattr(self, &#34;id&#34;, None)
        if not id_ and &#34;id&#34; in extra_fields:  # Pydantic field has priority
            id_ = extra_fields[&#34;id&#34;]
        if id_:
            db_model = db.query(self._orm_model).get(id_)
            if not db_model:
                raise ValueError(
                    f&#34;Provided id &#39;{id_}&#39; &#34;
                    f&#34;for table &#39;{self._orm_model.__tablename__}&#39; &#34;  # noqa
                    &#34;can&#39;t be found in the database &#34;
                    &#34;(sqlalchemy-pydantic-orm)&#34;
                )
            self.orm_update(db, db_model)
        else:
            db_model = self.orm_create(**extra_fields)
            db.add(db_model)

        return db_model</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="sqlalchemy_pydantic_orm.main.ORMBaseSchema"><code class="flex name class">
<span>class <span class="ident">ORMBaseSchema</span></span>
<span>(</span><span>**data:Â Any)</span>
</code></dt>
<dd>
<div class="desc"><p>The init is used for validation and throwing errors where needed.</p>
<p>Pydantic catches all ValueError's in initialization, and then outputs
the error message in a easy to read format with the specific class
name displayed.
Every error is given the "sqlalchemy-pydantic-orm" identifier to
distinguish between Pydantic's or SQLAlchemy's own errors
and those of this package.</p>
<p>For performance its better to execute the <code>super().__init__()</code> as late
as possible, only the _orm_model check requires it to work properly.</p>
<h2 id="args">Args</h2>
<p>**data (Any):
The fields and values to be validated.</p>
<h2 id="raises">Raises</h2>
<p>ValueError:
When orm_mode is set to false /
When the provided _orm_model is invalid</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class ORMBaseSchema(BaseModel):
    class Config:
        &#34;&#34;&#34;Pydantic&#39;s default config class except with orm_mode set to True.&#34;&#34;&#34;

        orm_mode = True

    def __init__(self, **data: Any):
        &#34;&#34;&#34;The init is used for validation and throwing errors where needed.

        Pydantic catches all ValueError&#39;s in initialization, and then outputs
        the error message in a easy to read format with the specific class
        name displayed.
        Every error is given the &#34;sqlalchemy-pydantic-orm&#34; identifier to
        distinguish between Pydantic&#39;s or SQLAlchemy&#39;s own errors
        and those of this package.

        For performance its better to execute the `super().__init__()` as late
        as possible, only the _orm_model check requires it to work properly.

        Args:
            **data (Any):
                The fields and values to be validated.

        Raises:
            ValueError:
                When orm_mode is set to false /
                When the provided _orm_model is invalid
        &#34;&#34;&#34;
        if not hasattr(config := self.Config, &#34;orm_mode&#34;):
            # Overwriting when not defined
            config.orm_mode = True
        elif not config.orm_mode:
            # Throws an error instead of overwriting to avoid confusion
            raise ValueError(
                &#34;sqlalchemy-pydantic-orm: &#34;
                &#34;When adding your own &#39;Config&#39; class, &#34;
                &#34;make sure you set &#39;orm_mode&#39; to &#39;true&#39;&#34;
            )

        super().__init__(**data)

        if type(self._orm_model) != DeclarativeMeta:
            raise ValueError(
                &#34;sqlalchemy-pydantic-orm: &#34;
                &#34;Provided orm_model is not a valid SQLAlchemy model, &#34;
                &#34;make sure it inherits the declarative base&#34;
            )
        elif &#34;_orm_model&#34; not in self.__private_attributes__:
            raise ValueError(
                &#34;sqlalchemy-pydantic-orm: &#34;
                &#34;Provided orm_model is not wrapped in a pydantic PrivateAttr&#34;
            )

    @property
    @abstractmethod
    def _orm_model(self) -&gt; Type[DeclarativeMeta]:
        &#34;&#34;&#34;The corresponding SQLAlchemy model class

        The property decorator is used together with the @abstractmethod
        decorator to enforce assignment.

        This variable/property has a leading underscore and can only be
        assigned as PrivateAttr (Pydantic). This is because a Pydantic schema
        iterates over it&#39;s own fields and would otherwise cause problems when
        encountering this variable/property.

        Returns:
            A SQLAlchemy model (indirectly) inherited from DeclarativeMeta
        &#34;&#34;&#34;
        pass

    def orm_create(self, **extra_fields: Any) -&gt; DeclarativeMeta:
        &#34;&#34;&#34;Method to convert a (nested) pydantic schema to a SQLAlchemy model.

        Using the validated fields in this class, together with the defined
        _orm_model, this recursive methods creates a (nested) SQLAlchemy model.

        Args:
            extra_fields (Any):
                Extra fields (keyword arguments) not defined in the pydantic
                schema used by the top level ORM model. The fields in the
                schema itself have priority.

                Usage example:
                    When using an API like FastAPI or Flask, you often get
                    the data as body while getting the id (foreign key) as
                    path parameter. This argument lets you add such an id from
                    a separate source.

        Returns:
            A SQLAlchemy model instance, that still has to be added to the db.

        Raises:
            TypeError:
                When a list is not fully consisted of other ORM schemas.
        &#34;&#34;&#34;
        current_level_fields = {}
        for field in self.__fields_set__:
            field_name = self.__fields__[field].alias
            value = getattr(self, field)
            if isinstance(value, ORMBaseSchema):  # One-to-one
                current_level_fields[field_name] = value.orm_create()

            elif isinstance(value, SUPPORTED_ITERABLES):  # One-to-many
                models = []
                for schema in value:
                    if not isinstance(schema, ORMBaseSchema):
                        raise TypeError(
                            &#34;Lists should only contain other schemas &#34;
                            f&#34;inherited from &#39;{ORMBaseSchema.__name__}&#39; &#34;
                            &#34;(sqlalchemy-pydantic-orm)&#34;
                        )
                    models.append(schema.orm_create())
                current_level_fields[field_name] = models

            else:  # value without relation
                current_level_fields[field_name] = value

        return self._orm_model(**extra_fields, **current_level_fields)

    def orm_update(self, db: Session, db_model: DeclarativeMeta) -&gt; None:
        &#34;&#34;&#34;Method to update a (nested) orm structure.

        This method recursively updates an orm model with it&#39;s relationships.

        In one-to-many relationships, each provided item without an id gets
        added as new item with the `orm_create()` method. When a valid id is
        provided it updates the item with the `orm_update()` method. It also
        keep track of the parsed database items, and afterwards deletes any
        unparsed item.

        Args:
            db (Session):
                Database session used for `.add()` and `.delete()`.
            db_model (DeclarativeMeta):
                The ORM model to be updated.

        Returns:
            Nothing, everything gets done in the provided db_model

        Raises:
            TypeError:
                When a list is not fully consisted of other ORM schemas.
            ValueError:
                When the provided db_model is not valid /
                When a given id is not found in the database
        &#34;&#34;&#34;
        if not isinstance(db_model, self._orm_model):
            raise ValueError(
                f&#34;Provided db_model &#39;{db_model}&#39; is not an instance of the &#34;
                f&#34;defined _orm_model &#39;{self._orm_model.__name__}&#39; &#34;
                &#34;(sqlalchemy-pydantic-orm)&#34;
            )
        for field in self.__fields_set__:
            field_name = self.__fields__[field].alias
            db_value = getattr(db_model, field_name)
            update_value = getattr(self, field)
            if isinstance(update_value, ORMBaseSchema):  # One-to-one
                if db_value:
                    update_value.orm_update(db, db_value)
                else:
                    setattr(db_model, field_name, update_value.orm_create())

            elif isinstance(update_value, SUPPORTED_ITERABLES):  # One-to-many
                parsed_items = set()
                for schema in update_value:
                    if not isinstance(schema, ORMBaseSchema):
                        raise TypeError(
                            &#34;Lists should only contain other schemas &#34;
                            f&#34;inherited from &#39;{ORMBaseSchema.__name__}&#39; &#34;
                            &#34;(sqlalchemy-pydantic-orm)&#34;
                        )
                    if item_id := getattr(schema, &#34;id&#34;, None):
                        try:
                            db_item = next(
                                item for item in db_value if item.id == item_id
                            )
                        except StopIteration:
                            raise ValueError(
                                f&#34;Provided id &#39;{item_id}&#39; &#34;
                                f&#34;for field &#39;{field_name}&#39; &#34;
                                &#34;can&#39;t be found in the database &#34;
                                &#34;(sqlalchemy-pydantic-orm)&#34;
                            ) from None  # removes unnecessary traceback

                        schema.orm_update(db, db_item)
                        parsed_items.add(db_item)
                    else:
                        new_item = schema.orm_create()
                        parsed_items.add(new_item)
                        db_value.append(new_item)

                for db_item in db_value:
                    if db_item not in parsed_items:
                        db.delete(db_item)
            else:
                setattr(db_model, field_name, update_value)

    def to_orm(self, db: Session, **extra_fields: Any) -&gt; DeclarativeMeta:
        &#34;&#34;&#34;Method that combines the functionality of orm_create &amp; orm_update.

        This method is a wrapper around the other two methods. When no id is
        provided, it creates a new model with orm_create, and when an id Ã­s
        provided, it retrieves and updates that model.

        In contrary to the orm_create function on its own, this function does
        add the newly created model to the database. So after the this method
        has been executed you only need to call `db.commit()` after.

        Args:
            db (Session):
            **extra_fields (Any):

        Returns:
            A SQLAlchemy model instance, which is either queried and updated,
                or newly created

        Raises:
            ValueError:
                When the provided id is not found in the database
        &#34;&#34;&#34;
        id_ = getattr(self, &#34;id&#34;, None)
        if not id_ and &#34;id&#34; in extra_fields:  # Pydantic field has priority
            id_ = extra_fields[&#34;id&#34;]
        if id_:
            db_model = db.query(self._orm_model).get(id_)
            if not db_model:
                raise ValueError(
                    f&#34;Provided id &#39;{id_}&#39; &#34;
                    f&#34;for table &#39;{self._orm_model.__tablename__}&#39; &#34;  # noqa
                    &#34;can&#39;t be found in the database &#34;
                    &#34;(sqlalchemy-pydantic-orm)&#34;
                )
            self.orm_update(db, db_model)
        else:
            db_model = self.orm_create(**extra_fields)
            db.add(db_model)

        return db_model</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>pydantic.main.BaseModel</li>
<li>pydantic.utils.Representation</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="sqlalchemy_pydantic_orm.main.ORMBaseSchema.Config"><code class="name">var <span class="ident">Config</span></code></dt>
<dd>
<div class="desc"><p>Pydantic's default config class except with orm_mode set to True.</p></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="sqlalchemy_pydantic_orm.main.ORMBaseSchema.orm_create"><code class="name flex">
<span>def <span class="ident">orm_create</span></span>(<span>self, **extra_fields:Â Any) â€‘>Â sqlalchemy.orm.decl_api.DeclarativeMeta</span>
</code></dt>
<dd>
<div class="desc"><p>Method to convert a (nested) pydantic schema to a SQLAlchemy model.</p>
<p>Using the validated fields in this class, together with the defined
_orm_model, this recursive methods creates a (nested) SQLAlchemy model.</p>
<h2 id="args">Args</h2>
<p>extra_fields (Any):
Extra fields (keyword arguments) not defined in the pydantic
schema used by the top level ORM model. The fields in the
schema itself have priority.</p>
<pre><code>Usage example:
    When using an API like FastAPI or Flask, you often get
    the data as body while getting the id (foreign key) as
    path parameter. This argument lets you add such an id from
    a separate source.
</code></pre>
<h2 id="returns">Returns</h2>
<p>A SQLAlchemy model instance, that still has to be added to the db.</p>
<h2 id="raises">Raises</h2>
<p>TypeError:
When a list is not fully consisted of other ORM schemas.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def orm_create(self, **extra_fields: Any) -&gt; DeclarativeMeta:
    &#34;&#34;&#34;Method to convert a (nested) pydantic schema to a SQLAlchemy model.

    Using the validated fields in this class, together with the defined
    _orm_model, this recursive methods creates a (nested) SQLAlchemy model.

    Args:
        extra_fields (Any):
            Extra fields (keyword arguments) not defined in the pydantic
            schema used by the top level ORM model. The fields in the
            schema itself have priority.

            Usage example:
                When using an API like FastAPI or Flask, you often get
                the data as body while getting the id (foreign key) as
                path parameter. This argument lets you add such an id from
                a separate source.

    Returns:
        A SQLAlchemy model instance, that still has to be added to the db.

    Raises:
        TypeError:
            When a list is not fully consisted of other ORM schemas.
    &#34;&#34;&#34;
    current_level_fields = {}
    for field in self.__fields_set__:
        field_name = self.__fields__[field].alias
        value = getattr(self, field)
        if isinstance(value, ORMBaseSchema):  # One-to-one
            current_level_fields[field_name] = value.orm_create()

        elif isinstance(value, SUPPORTED_ITERABLES):  # One-to-many
            models = []
            for schema in value:
                if not isinstance(schema, ORMBaseSchema):
                    raise TypeError(
                        &#34;Lists should only contain other schemas &#34;
                        f&#34;inherited from &#39;{ORMBaseSchema.__name__}&#39; &#34;
                        &#34;(sqlalchemy-pydantic-orm)&#34;
                    )
                models.append(schema.orm_create())
            current_level_fields[field_name] = models

        else:  # value without relation
            current_level_fields[field_name] = value

    return self._orm_model(**extra_fields, **current_level_fields)</code></pre>
</details>
</dd>
<dt id="sqlalchemy_pydantic_orm.main.ORMBaseSchema.orm_update"><code class="name flex">
<span>def <span class="ident">orm_update</span></span>(<span>self, db:Â sqlalchemy.orm.session.Session, db_model:Â sqlalchemy.orm.decl_api.DeclarativeMeta) â€‘>Â NoneType</span>
</code></dt>
<dd>
<div class="desc"><p>Method to update a (nested) orm structure.</p>
<p>This method recursively updates an orm model with it's relationships.</p>
<p>In one-to-many relationships, each provided item without an id gets
added as new item with the <code>orm_create()</code> method. When a valid id is
provided it updates the item with the <code>orm_update()</code> method. It also
keep track of the parsed database items, and afterwards deletes any
unparsed item.</p>
<h2 id="args">Args</h2>
<p>db (Session):
Database session used for <code>.add()</code> and <code>.delete()</code>.
db_model (DeclarativeMeta):
The ORM model to be updated.</p>
<h2 id="returns">Returns</h2>
<p>Nothing, everything gets done in the provided db_model</p>
<h2 id="raises">Raises</h2>
<p>TypeError:
When a list is not fully consisted of other ORM schemas.
ValueError:
When the provided db_model is not valid /
When a given id is not found in the database</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def orm_update(self, db: Session, db_model: DeclarativeMeta) -&gt; None:
    &#34;&#34;&#34;Method to update a (nested) orm structure.

    This method recursively updates an orm model with it&#39;s relationships.

    In one-to-many relationships, each provided item without an id gets
    added as new item with the `orm_create()` method. When a valid id is
    provided it updates the item with the `orm_update()` method. It also
    keep track of the parsed database items, and afterwards deletes any
    unparsed item.

    Args:
        db (Session):
            Database session used for `.add()` and `.delete()`.
        db_model (DeclarativeMeta):
            The ORM model to be updated.

    Returns:
        Nothing, everything gets done in the provided db_model

    Raises:
        TypeError:
            When a list is not fully consisted of other ORM schemas.
        ValueError:
            When the provided db_model is not valid /
            When a given id is not found in the database
    &#34;&#34;&#34;
    if not isinstance(db_model, self._orm_model):
        raise ValueError(
            f&#34;Provided db_model &#39;{db_model}&#39; is not an instance of the &#34;
            f&#34;defined _orm_model &#39;{self._orm_model.__name__}&#39; &#34;
            &#34;(sqlalchemy-pydantic-orm)&#34;
        )
    for field in self.__fields_set__:
        field_name = self.__fields__[field].alias
        db_value = getattr(db_model, field_name)
        update_value = getattr(self, field)
        if isinstance(update_value, ORMBaseSchema):  # One-to-one
            if db_value:
                update_value.orm_update(db, db_value)
            else:
                setattr(db_model, field_name, update_value.orm_create())

        elif isinstance(update_value, SUPPORTED_ITERABLES):  # One-to-many
            parsed_items = set()
            for schema in update_value:
                if not isinstance(schema, ORMBaseSchema):
                    raise TypeError(
                        &#34;Lists should only contain other schemas &#34;
                        f&#34;inherited from &#39;{ORMBaseSchema.__name__}&#39; &#34;
                        &#34;(sqlalchemy-pydantic-orm)&#34;
                    )
                if item_id := getattr(schema, &#34;id&#34;, None):
                    try:
                        db_item = next(
                            item for item in db_value if item.id == item_id
                        )
                    except StopIteration:
                        raise ValueError(
                            f&#34;Provided id &#39;{item_id}&#39; &#34;
                            f&#34;for field &#39;{field_name}&#39; &#34;
                            &#34;can&#39;t be found in the database &#34;
                            &#34;(sqlalchemy-pydantic-orm)&#34;
                        ) from None  # removes unnecessary traceback

                    schema.orm_update(db, db_item)
                    parsed_items.add(db_item)
                else:
                    new_item = schema.orm_create()
                    parsed_items.add(new_item)
                    db_value.append(new_item)

            for db_item in db_value:
                if db_item not in parsed_items:
                    db.delete(db_item)
        else:
            setattr(db_model, field_name, update_value)</code></pre>
</details>
</dd>
<dt id="sqlalchemy_pydantic_orm.main.ORMBaseSchema.to_orm"><code class="name flex">
<span>def <span class="ident">to_orm</span></span>(<span>self, db:Â sqlalchemy.orm.session.Session, **extra_fields:Â Any) â€‘>Â sqlalchemy.orm.decl_api.DeclarativeMeta</span>
</code></dt>
<dd>
<div class="desc"><p>Method that combines the functionality of orm_create &amp; orm_update.</p>
<p>This method is a wrapper around the other two methods. When no id is
provided, it creates a new model with orm_create, and when an id Ã­s
provided, it retrieves and updates that model.</p>
<p>In contrary to the orm_create function on its own, this function does
add the newly created model to the database. So after the this method
has been executed you only need to call <code>db.commit()</code> after.</p>
<h2 id="args">Args</h2>
<p>db (Session):
**extra_fields (Any):</p>
<h2 id="returns">Returns</h2>
<p>A SQLAlchemy model instance, which is either queried and updated,
or newly created</p>
<h2 id="raises">Raises</h2>
<p>ValueError:
When the provided id is not found in the database</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def to_orm(self, db: Session, **extra_fields: Any) -&gt; DeclarativeMeta:
    &#34;&#34;&#34;Method that combines the functionality of orm_create &amp; orm_update.

    This method is a wrapper around the other two methods. When no id is
    provided, it creates a new model with orm_create, and when an id Ã­s
    provided, it retrieves and updates that model.

    In contrary to the orm_create function on its own, this function does
    add the newly created model to the database. So after the this method
    has been executed you only need to call `db.commit()` after.

    Args:
        db (Session):
        **extra_fields (Any):

    Returns:
        A SQLAlchemy model instance, which is either queried and updated,
            or newly created

    Raises:
        ValueError:
            When the provided id is not found in the database
    &#34;&#34;&#34;
    id_ = getattr(self, &#34;id&#34;, None)
    if not id_ and &#34;id&#34; in extra_fields:  # Pydantic field has priority
        id_ = extra_fields[&#34;id&#34;]
    if id_:
        db_model = db.query(self._orm_model).get(id_)
        if not db_model:
            raise ValueError(
                f&#34;Provided id &#39;{id_}&#39; &#34;
                f&#34;for table &#39;{self._orm_model.__tablename__}&#39; &#34;  # noqa
                &#34;can&#39;t be found in the database &#34;
                &#34;(sqlalchemy-pydantic-orm)&#34;
            )
        self.orm_update(db, db_model)
    else:
        db_model = self.orm_create(**extra_fields)
        db.add(db_model)

    return db_model</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="sqlalchemy_pydantic_orm" href="index.html">sqlalchemy_pydantic_orm</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="sqlalchemy_pydantic_orm.main.ORMBaseSchema" href="#sqlalchemy_pydantic_orm.main.ORMBaseSchema">ORMBaseSchema</a></code></h4>
<ul class="">
<li><code><a title="sqlalchemy_pydantic_orm.main.ORMBaseSchema.Config" href="#sqlalchemy_pydantic_orm.main.ORMBaseSchema.Config">Config</a></code></li>
<li><code><a title="sqlalchemy_pydantic_orm.main.ORMBaseSchema.orm_create" href="#sqlalchemy_pydantic_orm.main.ORMBaseSchema.orm_create">orm_create</a></code></li>
<li><code><a title="sqlalchemy_pydantic_orm.main.ORMBaseSchema.orm_update" href="#sqlalchemy_pydantic_orm.main.ORMBaseSchema.orm_update">orm_update</a></code></li>
<li><code><a title="sqlalchemy_pydantic_orm.main.ORMBaseSchema.to_orm" href="#sqlalchemy_pydantic_orm.main.ORMBaseSchema.to_orm">to_orm</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.9.2</a>.</p>
</footer>
</body>
</html>